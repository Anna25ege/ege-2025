Тип 1 - поиск наибольшего/наименьшего числа, при котором выражение тождественно истинно

Всегда следи:
1. За допустимыми значениями
	натуральное A - range(1, 10_000)
	неотрицательное A - range(0, 10_000)
	целое A - range(-10_000, 10_000)
2. Что нужно дать в ответ
	Наибольшее значение - range(1, 10_000)[::-1]
	Наименьшее значение - range(1, 10_000)

Логика действий:
Перебираем все варианты значения A через цикл. Для каждого A запускаем свой цикл для перебора значений x.
Для каждого x подставляем значения в выражение из условия и действует по следующей логике: если выражение истинно,
то все хорошо, переходим на следующий шаг цикла. Если выражение ложно, останавливаем работу цикла, переходим к следующему A.
Если цикл завершится без break, это значит, что оно было истинным при всех возможных x и следовательно наше выражение тождественно истинно.

Пример 1:
Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на натуральное число m». Для какого наименьшего натурального числа А формула
(ДЕЛ(x, 2) → ¬ДЕЛ(x, 3)) \/ (x + A ≥ 80)
тождественно истинна (т.е. принимает значение 1) при любом натуральном значении переменной х?
Решение 1:
	def dell(n, m):
	   return n % m == 0
	def funk(A):
	   for x in range(1, 10_000):
	       f = (dell(x, 2) <= (not dell(x, 3))) or (x + A >= 80)
	       if not f:
	           return False
	   return True
	for A in range(1, 10_000):
	   if funk(A):
	       print(A)
	       break

Пример 2:
Для какого наибольшего целого неотрицательного числа А выражение
(x + 2y > A) ∨ (y < x) ∨ (x < 30)
тождественно истинно (т.е. принимает значение 1) при любых целых неотрицательных х и у?
Решение 2:
	def funk(A):
	   for x in range(1, 1000):
	       for y in range(1, 1000):
	           f = (x + 2 * y > A) or (y < x) or (x < 30)
	           if not f:
	               return False
	   return True
	for A in range(1, 1000)[::-1]:
	   if funk(A):
	       print(A)
	       break


Тип 2 - поиск наибольшего/наименьшего отрезка, при котором выражение тождественно истинно/ложно
from itertools import combinations

def f(x):
    A = A1 <= x <= A2
    P = 23 <= x < 45
    Q = 34 <= x <= 56
    return (not A) or (not P) and Q

# числовая прямая
# eps позволяет проверить выколотые точки
line = [i + eps for i in range(20, 60) for eps in [0, 0.1, 0.9]]

ans = []
# перебираем все потенциальных отрезков
for A1, A2 in combinations(line, 2):
    # (f(x) == 1, если выражение тождественно истинно), (== 0, если ложно)
    if all(f(x) == 1 for x in line):
        ans.append(A2 - A1)
print(max(ans))  # пишем min и max в зависимости от наименьший или больший отрезок необходимо дать в ответ
